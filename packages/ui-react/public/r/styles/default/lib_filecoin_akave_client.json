{
	"name": "lib_filecoin_akave_client",
	"type": "registry:lib",
	"dependencies": [],
	"files": [
		{
			"path": "lib/filecoin_akave_client.ts",
			"content": "import ky, { DownloadProgress } from \"ky\";\n\nexport interface AkaveFile {\n\tName: string;\n\tRootCID: string;\n\tSize: string;\n\tCreatedAt: string;\n}\n\nexport interface AkaveBucket {\n\tID: string;\n\tName: string;\n\tCreatedAt: string;\n\tfiles: File[];\n}\n\n/**\n * Authentication and browser-compatability are to be confirmed\n * TODO refactor akave config object\n */\n\nconst AKAVE_ENDPOINT_URL = \"localhost:3000\";\n\nexport const getBucketMetadata = ({\n\takaveEndpointUrl = AKAVE_ENDPOINT_URL,\n\tbucketName,\n}: {\n\takaveEndpointUrl: string;\n\tbucketName: string;\n}) => {\n\tconst url = `${akaveEndpointUrl}/buckets/${bucketName}`;\n\n\treturn ky(url).then((response) => response.json());\n};\n\nexport const listBucketFiles = ({\n\takaveEndpointUrl = AKAVE_ENDPOINT_URL,\n\tbucketName,\n}: {\n\takaveEndpointUrl: string;\n\tbucketName: string;\n}): Promise<AkaveFile[]> => {\n\tconst url = `${akaveEndpointUrl}/buckets/${bucketName}/files`;\n\n\treturn ky(url)\n\t\t.then((response) => response.json<{ data: AkaveFile[] }>())\n\t\t.then(({ data }) => {\n\t\t\treturn data || [];\n\t\t});\n};\n\ntype ListBucketRes = {\n\tdata?: Omit<AkaveBucket, \"files\">[];\n\tsuccess: boolean;\n};\nexport const listBuckets = ({\n\takaveEndpointUrl = AKAVE_ENDPOINT_URL,\n}: {\n\takaveEndpointUrl: string;\n}) => {\n\tconst url = `${akaveEndpointUrl}/buckets`;\n\n\treturn ky(url).then((response) => response.json<ListBucketRes>());\n};\n\ntype CreateBucketRes = {\n\tdata?: {\n\t\tID: string;\n\t\ttransactionHash: string;\n\t};\n\tsuccess: boolean;\n};\n\nexport const createBucket = ({\n\takaveEndpointUrl = AKAVE_ENDPOINT_URL,\n\tbucketName,\n}: {\n\takaveEndpointUrl: string;\n\tbucketName: string;\n}) => {\n\tconst url = `${akaveEndpointUrl}/buckets`;\n\n\treturn ky\n\t\t.post(url, {\n\t\t\tjson: { bucketName },\n\t\t})\n\t\t.then((response) => response.json<CreateBucketRes>());\n};\n\nexport const createDownloadUrl = ({\n\takaveEndpointUrl = AKAVE_ENDPOINT_URL,\n\tbucketName,\n\tfileName,\n}: {\n\takaveEndpointUrl: string;\n\tbucketName: string;\n\tfileName: string;\n}) => {\n\treturn `${akaveEndpointUrl}/buckets/${bucketName}/files/${fileName}/download`;\n};\n\nexport type UploadParams = {\n\takaveEndpointUrl: string;\n\tbucketName: string;\n\tfileName: string;\n\tfile: File | Blob | Object;\n\tuploadProgressCallback?: (data: DownloadProgress) => void;\n};\n\nconst createUploadEndpoint = ({\n\takaveEndpointUrl = AKAVE_ENDPOINT_URL,\n\tbucketName,\n}: {\n\takaveEndpointUrl: string;\n\tbucketName: string;\n}) => {\n\treturn `${akaveEndpointUrl}/buckets/${bucketName}/files`;\n};\n\n// @warning: Seems only form data is working\n\nexport const uploadFileObject = ({\n\takaveEndpointUrl = AKAVE_ENDPOINT_URL,\n\tbucketName,\n\tfileName,\n\tfile,\n}: UploadParams): Promise<any> => {\n\tconst endpoint = createUploadEndpoint({\n\t\takaveEndpointUrl,\n\t\tbucketName,\n\t});\n\n\tconst options = typeof file === \"string\" ? { body: file } : { json: file };\n\treturn ky.post(endpoint, options).then((res) => res.json());\n};\n\nexport const uploadFileWithFormData = async ({\n\takaveEndpointUrl = AKAVE_ENDPOINT_URL,\n\tbucketName,\n\tfileName,\n\tfile,\n\tuploadProgressCallback,\n}: UploadParams): Promise<any> => {\n\tconst endpoint = createUploadEndpoint({\n\t\takaveEndpointUrl,\n\t\tbucketName,\n\t});\n\n\tconst formData = new FormData();\n\t// @ts-ignore\n\tformData.append(\"file\", file);\n\n\t// Caused by: RequestContentLengthMismatchError: Request body length does not match content-length header\n\n\t// CORS error, to confirm if akave should work at browser\n\treturn ky\n\t\t.post(endpoint, {\n\t\t\tbody: formData,\n\t\t\ttimeout: 7200000,\n\t\t\tonDownloadProgress: (progress: DownloadProgress) => {\n\t\t\t\tuploadProgressCallback?.(progress);\n\t\t\t},\n\t\t})\n\t\t.then((res) => res.json())\n\t\t.then((results: any) => {\n\t\t\tconst { success, data } = results;\n\t\t\tif (success) {\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\tthrow new Error(\"Upload Failed\");\n\t\t});\n};\n",
			"type": "registry:lib"
		}
	],
	"registryDependencies": []
}
