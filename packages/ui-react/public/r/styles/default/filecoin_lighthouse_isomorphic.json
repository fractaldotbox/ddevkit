{
	"name": "filecoin_lighthouse_isomorphic",
	"type": "registry:lib",
	"dependencies": [],
	"files": [
		{
			"path": "lib/filecoin_lighthouse_isomorphic.ts",
			"content": "import kavach from \"@lighthouse-web3/kavach\";\nimport lighthouse from \"@lighthouse-web3/sdk\";\nimport { IUploadProgressCallback } from \"@lighthouse-web3/sdk/dist/types\";\nimport ky, { DownloadProgress } from \"ky\";\nimport { http, Account, createWalletClient } from \"viem\";\nimport { sepolia } from \"viem/chains\";\nimport { GatewayStrategy } from \"../gateway-strategy\";\nimport { uploadFiles as uploadFilesLighthouse } from \"./browser\";\n// import { CID } from 'multiformats/cid'\n\n// Supposedly lighthouse can be treeshake for node/browser, to be validated\n\nexport const LIGHTHOUSE_API_ROOT =\n\t\"https://api.lighthouse.storage/api/lighthouse/\";\n\n// Consider model as action insteadz\nexport const createLighthouseParams = async ({\n\taccount,\n\toptions,\n}: {\n\taccount: Account;\n\toptions: {\n\t\tapiKey?: string;\n\t};\n}): Promise<[string, string, string]> => {\n\tconst { apiKey } = options;\n\tif (!apiKey) {\n\t\tthrow new Error(\"Lighthouse apiKey required\");\n\t}\n\n\tconst signedMessage = await signAuthMessage(account);\n\treturn [apiKey, account.address, signedMessage];\n};\n\nexport const signAuthMessage = async (account: any) => {\n\tconst client = createWalletClient({\n\t\taccount,\n\t\tchain: sepolia,\n\t\ttransport: http(),\n\t});\n\n\tconst authMessage = await kavach.getAuthMessage(account.address);\n\n\tconst { error, message } = authMessage;\n\tif (error || !message) {\n\t\tthrow new Error(\"authMessage error\" + error);\n\t}\n\n\treturn client.signMessage({\n\t\taccount,\n\t\tmessage: message,\n\t});\n};\n\n// Api design issue cannot pass callback when deal params not specified\n\n// Further work overriding sdk required for customizing form headers, timeout etc\n// consider direct invoke /api/v0/add?wrap-with-directory\n\nexport const uploadFiles = async (\n\tfiles: File[],\n\tapiKey: string,\n\tuploadProgressCallback?: (data: DownloadProgress) => void,\n): Promise<any> => {\n\tlet output;\n\n\tif (window) {\n\t\toutput = await uploadFilesLighthouse<false>({\n\t\t\tfiles,\n\t\t\tconfig: {\n\t\t\t\taccessToken: apiKey,\n\t\t\t},\n\t\t\tuploadProgressCallback,\n\t\t});\n\t} else {\n\t\t// currently accept first file as folder\n\t\tconst [file] = files;\n\t\toutput = await lighthouse.upload(\n\t\t\tfile,\n\t\t\tapiKey,\n\t\t\tundefined,\n\t\t\t(data: IUploadProgressCallback) => {\n\t\t\t\tif (!uploadProgressCallback) return;\n\t\t\t\tuploadProgressCallback({\n\t\t\t\t\tpercent: data.progress,\n\t\t\t\t\ttransferredBytes: 0,\n\t\t\t\t\ttotalBytes: 0,\n\t\t\t\t});\n\t\t\t},\n\t\t);\n\t}\n\n\tif (!output?.data?.Hash) {\n\t\tthrow new Error(\"Upload failed\");\n\t}\n\n\treturn {\n\t\tname: output.data.Name,\n\t\tcid: output.data.Hash,\n\t\tsize: parseInt(output.data.Size, 10),\n\t};\n};\n\nexport const retrievePoDsi = async (cid: string) => {\n\tlet response = await ky.get(`${LIGHTHOUSE_API_ROOT}/get_proof`, {\n\t\tsearchParams: {\n\t\t\tcid,\n\t\t\tnetwork: \"testnet\", // Change the network to mainnet when ready\n\t\t},\n\t});\n\tconst data = await response.json();\n\treturn JSON.parse(data);\n};\n\n// .uploadText has no deal params options\n\nexport const uploadText = async (text: string, apiKey: string) => {\n\tif (!text) {\n\t\tthrow new Error(\"Empty text\");\n\t}\n\n\tconst response = await lighthouse.uploadText(text, apiKey);\n\n\tconst { data } = response;\n\n\treturn {\n\t\tname: data.Name,\n\t\tcid: data.Hash,\n\t\tsize: parseInt(data.Size, 10),\n\t};\n};\n\nexport const uploadEncryptedFileWithText = async (\n\ttext: string,\n\tapiKey: string,\n\tpublicKey: string,\n\tsignedMessage: string,\n) => {\n\tconst response = await lighthouse.textUploadEncrypted(\n\t\ttext,\n\t\tapiKey,\n\t\tpublicKey,\n\t\tsignedMessage,\n\t);\n\n\tconst { data } = response;\n\n\treturn {\n\t\tname: data.Name,\n\t\tcid: data.Hash,\n\t};\n};\n\nexport const getLighthouseGatewayUrl: GatewayStrategy = (cid: string) => {\n\treturn \"https://gateway.lighthouse.storage/ipfs/\" + cid;\n};\n\nexport const retrieveFile = async (cid: string) => {\n\treturn ky(getLighthouseGatewayUrl(cid)).arrayBuffer();\n};\n",
			"type": "registry:lib"
		}
	],
	"registryDependencies": []
}
